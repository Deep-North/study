
/*************************************************************
	Практическое занятие №5. 
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции
	Структуры
*************************************************************/
#define _CRT_SECURE_NO_WARNINGS
#include <tchar.h>
#include <iostream>
//#include <cstdio>
#include "other.h"


#define	  stop __asm nop

BOOK globalBOOK;

int _tmain()
{
	setlocale(LC_ALL, "Russian");

	////////////////////////////////////////////////////////////////////	
		//Тема "Старые" потоковые функции стандартной библиотеки
	{
		//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
		std::cout << "====================================================================\n\nЗадание 5.1.\n\n";
		int A, B, C;

		scanf("%d%d%d%*c", &A, &B, &C);
		std::cout << "A: " << A << "\n" << "B: " << B << "\n" << "C: " << C << "\n";

		//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5

		float x, y;
		for (x = -2; x <= 2; x += 0.5)
		{
			y = (A * x*x + B * x + C);
			printf("y = %d * (%5.1f * %5.1f) + ( %d * %5.1f ) + %d = %3.1f\n", A, x, x, B, x, C, y);
		}

		stop
	}

	///////////////////////////////////////////////////////////////////
		//Тема Указатели на функции
	{
		std::cout << "====================================================================\n\nЗадание 5.2.\n\n";
		//Задание 1. Указатель на функцию. "Калькулятор".
		//Напишите функции:
		//1)Sum - принимает два значения double и возвращает сумму
		//этих значений
		//2)Sub- принимает два значения double и возвращает разность
		//этих значений
		//3)Mul - *
		//4)Div - /
		//5)а для возведения в степень можете использовать функцию стандартной библиотеки
		//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
		//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
		//		вариантов этой функции, а Вам потребуется сформировать указатель на 
		//		double pow(double, double);

		//Предоставьте пользователю	следующую возможность:
		//пока пользователь хочет пользоваться услугами Вашего калькулятора,
		//он может вводить два значения и знак операции
		//а Вы выводите результат. Результат получаете посредством вызова
		//соответствующей Вашей функции по указателю.
		//Предусмотрите возможность ввода непредусмотренного знака операции

		printf("Vybor(1, 1, +) = %f\n", Vybor(1, 1, PLUS));
		printf("Vybor(1, 1, -) = %f\n", Vybor(1, 1, MINUS));
		printf("Vybor(3, 2.1, *) = %f\n", Vybor(3, 2.1, MUL));
		printf("Vybor(3, 1.5, /) = %f\n", Vybor(3, 1.5, DIV));
		printf("Vybor(2, 8, **) = %f\n", Vybor(2, 8, POW));
		printf("Vybor(10.3, 0.5, ?) = %f\n", Vybor(10.3, 0.5, EF));

		stop
	}
	{
		std::cout << "====================================================================\n\nЗадание 5.3.\n\n";
		//Задание 3. Указатель на функцию в качестве аргумента.
		//Дана заготовка функции сортировки любых объектов - Sort.
		//Функция принимает следующие параметры:
		//1) указатель на первый сортируемый элемент
		//2) количество сортируемых элементов
		//3) размер элемента в байтах
		//4) указатель на функцию перестановки элементов
		//5) указатель на функцию сравнения элементов

		//3a. Напишите функцию перестановки двух целых значений -
		// SwapInt, которая принимает два void указателя и 
		//меняет значения местами

		//Напишите функцию сравнения двух целых значений -
		// CmpInt, которая принимает два void указателя и
		//возвращает int результат сравнения: 
		//<0 - первый элемент меньше, чем второй
		//=0 - равны
		//>0 - первый элемент больше, чем второй

		int nAr[] = { 10, 25, 3, -4, 11, -100 };	//массив для сортировки

		//Печать исходного массива
		std::cout << "Массив типа int:\n";
		for (int i = 0; i < sizeof(nAr) / sizeof(nAr[0]); i++)
		{
			std::cout << nAr[i] << ' ';
		}
		std::cout << "\n";

		//Вызов сортировки
		std::cout << "Отсортированный массив типа int:\n";
		int nTotal = (sizeof(nAr) / sizeof(nAr[0]));			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки
		for (int i = 0; i < sizeof(nAr) / sizeof(nAr[0]); i++)
		{
			std::cout << nAr[i] << ' ';
		}
		std::cout << "\n";

		stop


			//Задание 3б. По аналогии с 8а создайте вспомогательные
			//функции - SwapDouble и CmpDouble и вызовите функцию Sort
			//для сортировки массива вещественных значений.
			std::cout << "\nМассив типа double:\n";
		double dAr[] = { 40.1, 15.2, 8.3, -22.44, 71.5, -95.8 };	//массив для сортировки

		//Печать исходного массива
		for (int i = 0; i < sizeof(dAr) / sizeof(dAr[0]); i++)
		{
			std::cout << dAr[i] << ' ';
		}
		std::cout << "\n";

		//Вызов сортировки
		int dTotal = (sizeof(dAr) / sizeof(dAr[0]));			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&dAr[0]), dTotal, sizeof(double), SwapDouble, CmpDouble);
		std::cout << "Отсортированный массив типа double:\n";
		//Печать результатов сортировки
		for (int i = 0; i < sizeof(dAr) / sizeof(dAr[0]); i++)
		{
			std::cout << dAr[i] << ' ';
		}
		std::cout << "\n";

		stop

			//Задание 3в*. По аналогии с 8а создайте вспомогательные
			//функции - SwapStr и CmpStr и вызовите функцию Sort
			//для сортировки массива указателей на строки.
			std::cout << "\nМассив типа str:\n";
		char s[] = "QWERTY";
		const char* arStr[5] = { "WWW", "SDF", "ABC", &s[0], "BDE" };
		for (int i = 0; i < 5; i++)
		{
			std::cout << arStr[i] << " ";
		}
		std::cout << "\n";
		int cTotal = 5;
		Sort(reinterpret_cast<char*>(&arStr[0]), cTotal, sizeof(char*), SwapStr, CmpStr);
		for (int i = 0; i < 5; i++)
		{
			std::cout << arStr[i] << " ";
		}
		std::cout << "\n";

		stop
	}

	{
	//Задание 4. Массивы указателей на функцию.
	std::cout << "====================================================================\n\nЗадание 5.4.\n\n";
	//Напишите несколько функций вида
	//const char* GetString1();
	//const char* GetString2();
	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)


	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
	const char* (*MUF[5])() = { &GetString1, &GetString2, &GetString3, &GetString4, &GetString5 };

	//Введите номер функции, которую Вы хотите вызвать:
	int n = 4;

	//Вызовите функцию 
	const char* r = MUF[n]();

	//Распечатайте результат
	printf("%s \n", r);
	stop
	}
//////////////////////////////////////////////////////////////////////////////////////

	//Тема. Структуры С.
	std::cout << "====================================================================\n\nЗадание 5.5.\n\n";
	//Задание 5. Объявите структуру BOOK, описывающую книгу
	//(автор, заглавие, год издания, цена, категория…).
	//Подумайте: какого типа могут быть поля структуры.
	//Подсказка: объявление структуры рекомендуется выносить
	//в заголовочный файл.

	//см. в other.h


	//Задание 6. Создайте разными способами (глобальный, локальный, статический,
	//динамический) экземпляры (объекты) типа BOOK (без инициализации).
	//Определите - сколько памяти отводит компилятор под каждый
	//такой объект. Как инициализируются (или не инициализируются) поля
	//структуры. Подумайте: от чего зависит объем выделяемой памяти?

	static BOOK staticBook;
	BOOK *pbook = new BOOK();
	BOOK book1;


	//Задание 7. Заполните поля созданных объектов.
	//Замечание: если для хранения строки используется массив, необходимо
	//предусмотреть "защиту" от выхода за границы массива.

	book1.year = 1984;
	book1.price = 500.00;
	BookSetTitle(book1, "Математика");
	BookSetAuthor(book1, "Петров");
	BookSetCategory(book1, "Точные науки");
	
	pbook->year = 2000;
	pbook->price = 500.00;
	BookSetTitle(*pbook, "Русский язык");
	BookSetAuthor(*pbook, "Иванов");
	BookSetCategory(*pbook, "Лингвистика");

	globalBOOK.year = 1999;
	globalBOOK.price = 500.00;
	BookSetTitle(globalBOOK, "Физика");
	BookSetAuthor(globalBOOK, "Сидоров");
	BookSetCategory(globalBOOK, "Точные науки");

	staticBook.year = 2010;
	staticBook.price = 500.00;
	BookSetTitle(staticBook, "Химия");
	BookSetAuthor(staticBook, "Васильев");
	BookSetCategory(staticBook, "Точные науки");


	printf("Размер статической книги: %lu \n", sizeof(staticBook));
	//printBOOK(staticBook);
	printf("Размер глобальной книги: %lu \n", sizeof(globalBOOK));
	//printBOOK(globalBOOK);
	printf("Размер локальной книги: %lu \n", sizeof(book1));
	//printBOOK(book1);
	printf("Размер динамической книги: %lu \n", sizeof(*pbook));
	//printBOOK(*pbook);
	
	stop
		//Задание 8. Напишите функцию, выводящую на экран реквизиты книги.
		//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
		//Для вывода на консоль используйте функцию стандартной библиотеки
		//printf

	printBOOK(staticBook);
	printBOOK(globalBOOK);
	printBOOK(book1);
	printBOOK(*pbook);
	
	stop
	//Задание 9. Напишите функцию для формирования полей структуры.
	//Для ввода используйте функцию стандартной библиотеки scanf
	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меньше, чем... (год появления письменности), категорию пользователь
	//должен выбирать из существующих, цена не может быть отрицательной...

	BOOK *book2 = makeBook();
	printBOOK(*book2);
	delete book2;
	
	stop
	return 0;
	
}//main

