/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/
#define _USE_MATH_DEFINES
//#define _UNICODE
#include <cmath>
#include <iostream>
#include <tchar.h>

#if defined _DEBUG
#include "1.h"
#else
#include "2.h"
#endif


#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку
int _tmain()
{
	// ********************************************************

	

	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
		//1.1
		{
		int y;//Задайте значение y, например, с помощью потока ввода
		int x;
		setlocale(LC_ALL, "Russian");
		std::cout << "Введите число: " << std::endl;
		std::cin >> y;
		//С помощью побитовых операторов и операторов сдвига выведите значение "y"
		//на консоль в двоичном виде, например:
		//если y==9, то
		// а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)
		for (x=sizeof(y)*8-1; x>=0; x--)
		{
			std::cout << ((y >> (x))&1);
		}
		std::cout << '\n';

		// б) пропустите незначащие нули -  1 0 0 1

		for (x = sizeof(y) * 8; x > 0; x--)
		{
			if ((y >> (x-1 )) ==0) continue;
			std::cout << ((y >> (x - 1)) & 1);
		}
		std::cout << '\n';
		system("pause");
		stop
		}


		//1.2 Дана целая переменная
		{
			int y;//Задайте значение y, например, с помощью потока ввода

			//"Сдвиньте" все единицы в сформированном значении вправо, например:
			//было:   0100 1111 0000 0000 0110 1111 0000 0010
			//стало:  0000 0000 0000 0000 0000 1111 1111 1111
			//Реализовать задачу посредством одного цикла!

			int x;
			int n = (-1);
			setlocale(LC_ALL, "Russian");
			std::cout << "Введите число: " << std::endl;
			std::cin >> y;

			for (x = 0; x < (sizeof(y) * 8); x++)
			{
				if ((y & 1) == 1)
				{
					n = (n << 1);
				}
				y = (y >> 1);
			}
			n = ~n;

			// Вывод числа для проверки
			for (x = sizeof(n) * 8; x>0; x--)
			{
				std::cout << ((n >> (x - 1)) & 1);
			}
			std::cout << '\n';

			std::cout << '\n';
			system("pause");

		}

		

		//1.3 Какие операции следует применить к заданному ниже операнду sNum для
		//того, чтобы переменная sRes приняла требуемое значение?
		//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
		//использовать один оператор (и при необходимости маску) 
		//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
		//можно получить любое значение => этот оператор предполагается использовать
		//в том случае, когда все остальные уже "не спасают" 
	{
		short sNum = 0x8008;
		short sRes;

		//0x7ff7
		sRes = ~sNum;

		//0x8ff8
		sRes = sNum | 0x0ff0;

		//0x0008
		sRes = sNum & 0x000f;

		//0x7f08
		sRes = sNum ^ 0xff00;

		//0xf001
		sRes = sNum >> 3;

		//0x0010
		sRes = sNum << 1;
		stop
	}

	stop
		// ********************************************************
			//Задание 2. Директивы препроцессора

			//2.1. Использование "математических" макросов стандартной библиотеки:
			//в заголовочном файле <cmath> (который в свою очередь включает старый
			//файл math.h) определены часто используемые математические
			//константы, например M_PI. Воспользуйтесь этой константой для
			//вычисления длины окружности.
			//Обратите внимание: определения констант в свою очередь тоже заключены
			//в директивы условной трансляции. Что еще, кроме подключения заголовочного
			//файла, требуется сделать???

	{
		double P, R;
	R = 10.;
	P = 2 * R * M_PI;
	stop
	}


		//2.2.Макросы с параметрами.
		//2.2.1 Напишите свою макроподстановку LENGTH которая вычисляет длину окружности.
		// протестируйте написанный макрос для следующих ситуаций:
	{
#define LENGHT(R)  (2 * (R) * M_PI)
		float l1 = LENGHT(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGHT(2); // должно быть 0.07957...

		stop
	}



	//2.2.2 определите макрос MAX(A, B)  для вычисления большего
	//значения из двух.

	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
	{
#define MAX(A,B) ((A>B) ? (A):(B)) //чем больше скобок, тем лучше :-))))
		int i = 10, j = 12, k;
		k = MAX(i, j);
		k = MAX(j, i) * 2;
		k = MAX(j, i + 3);
		k = MAX(i--, j++); // тут можно предложить сделать префиксный инкремент и декремент,
							//но все равно получится неправильно, т.к. инкремент произойдет дважды.

		stop
	}

	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	{
		//int ex;
#define EXCHANGE(X, Y) {int ex=X; X=Y; Y=ex;}
		int x1 = 1, y1 = -1;
		EXCHANGE(x1, y1);

		int x2 = 100, y2 = -100; // при разных типах переменных компилятор выдает ошибку
		EXCHANGE(x2, y2);

		stop
	}

	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?
	{
		//#define NNN          //Убирая или добавляя эту и следующую строчку
		//#define MMM          //можно влиять на значение переменной.

		int iNN;
#if defined NNN && defined MMM
		iNN = 0;
#elif defined MMM
		iNN = 1;
#elif defined NNN 
		iNN = 2;

#else
		iNN = -1;
#endif

		stop
	}



	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros

	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration

	{
#if defined _DEBUG
		std::cout << (__FILE__);// в настройках поставил галочку "use full paths"
		std::cout << ("\n");
		std::cout << (__LINE__);
		std::cout << ("\n");
		std::cout << (__TIME__);
		std::cout << ("\n");
		std::cout << (__FUNCDNAME__);
		std::cout << ("\n");


#else
		std::cout << "Release configuration!";
#endif // DEBUG
		stop
	}


	//Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, объявите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.

	{
		//int n;
#if defined _UNICODE
		typedef wchar_t CHAR;
#define TEXT(n) L##n
#else
		typedef char CHAR;
#define TEXT(n) n
#endif
		CHAR y = TEXT('Ф');	
		size_t n = sizeof(y);
		std::cout << n;

		stop
	}





	// ********************************************************
		//Задание 3.Заголовочные файлы. Директива #include
		//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
		//В каждом заголовочном файле объявите перечисление с одинаковыми именами
		//констант, но сопоставьте именованным константам разные значения, например:
		//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
		//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
		//констант из 1.h, а в RELEASE-версии значениями констант из 2.h

	{
#if defined _DEBUG
		std::cout << My1;
#else
		std::cout << My1;
#endif
		stop
	}



	// ********************************************************

		//Задание 4. Указатели
		//Объявите объекты разных типов и проинициализируйте их.
		//Объявите указатели соответствующих типов и проинициализируйте их
		//адресами заданных объектов. 
		//Выполняя задание, с помощью отладчика посмотрите, какие значения
		//будут присвоены переменным-указателям и на что эти указатели
		//"указывают"
	{
		int x1 = 10;
		double x2 = 0.5;
		char x3 = 'A';
		float x4 = 10.1;

		int* p1 = &x1;//+		p1	0x00d8f984 {10}	int *
		double* p2 = &x2;//+	p2	0x00d8f974 {0.50000000000000000}	double *
		char* p3 = &x3;//+		p3	0x00d8f96b "AММММММММ"	char *
		float* p4 = &x4;//+		p4	0x00d8f95c {10.1000004}	float *

		stop
	}



		//Задание 4а. Объявите указатель на тип char и проинициализируйте
		//его адресом строкового литерала. Присвойте переменной типа char значение
		//любого элемента строки.
		//Проверьте - возможно ли присвоить какое-либо значение по адресу,
		//задаваемому указателем?
	{
		//char str[] = "Stroka";
		const char* str = "Stroka";
		//str[2] = 'S';//Exception thrown: write access violation.
		//этот вариант является недопустимым по причине, что "str" является указателем,
		//смотрящим на константный объект, а любая запись в константный объект запрещена.
		stop
}


	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3};//+		nAr	0x0075fc7c {1, 3, 0}	int[3]// создали и проинициализировали массив
																// с признаком конца - 0
		int* pn = &nAr[0];//+		pn	0x0075fc7c {1}	int * создали указатель на первый элемент массива
		(*pn)++;		  //		*pn	2	int               увеличили значение переменной по указателю
		pn++;				//+		pn	0x0075fc80 {3}	int * увеличили (сдинули) значение указателя

		char cAr[]={'A','B','C','D'};//+	cAr	0x0075fc64 "ABCD...	char[4]// создали массив литералов
		char* pc = &cAr[0];//+	pc	0x0075fc64 "ABCDММММММММЂьu"	char * //создали указатель на первый
																			//элемент массива
		(*pc)=(*pc)+5;	//		*pc	70 'F'	char //разыменовали указатель, значение по указателю (первый
												 //элемент массива) увеличили на 5 (A стало F)
		pc=pc+3;//+		pc	0x0075fc67 "DММММММММЂьu"	char * //увеличили (сдинули) значение указателя на 3 байта
	
		double dAr[3]={1.0,2.0};//+		dAr	0x0075fc38 {1.0000000000000000, 2.0000000000000000, 0.00000000000000000}	double[3]
								//создали массив типа дабл
		double* pd1 = &dAr[0];//+		pd1	0x0075fc38 {1.0000000000000000}	double *
								//создали указатель на первый элемент этого массива
		double* pd2 = pd1;//+		pd2	0x0075fc38 {1.0000000000000000}	double *
								//создали указатель на указатель на первый элемент массива
		(*pd2)+=2;//		*pd2	3.0000000000000000	double
							//разыменовали второй указатель, первый указатель увеличили на 2
		pd2+=2;//+		pd2	0x0075fc48 {0.00000000000000000}	double *
							//увеличили на 2 второй указатель

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];//+		pd1	0x0075fc38 {3.0000000000000000}	double *
		pd2 = &dAr[1];//+		pd2	0x0075fc40 {2.0000000000000000}	double *
		int nNumber=pd2 - pd1;//		nNumber	1	int
		//В результате вычитания получается число элементов базового типа, находящихся между указателями.
		//Разность двух указателей – это разность их значений, деленная на размер типа в байтах.

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		std::cout << pd1;
		std::cout << '\n';
		std::cout << pd2;
		stop
	}


	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

    unsigned int nObject5=0x55667788;//		nObject5	0x55667788	unsigned int
	unsigned int* pnObject5=&nObject5;//+		pnObject5	0x004ff56c {0x55667788}	unsigned int *

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)
	unsigned char* pucObject5;
//	pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	char cc = *(pucObject5++);//		cc	0x88 '€'	char
	cc = (*pucObject5)++;//		cc			0x77 'w'	char
						 //		*pucObject5	0x78 'x'	unsigned char

	cc = ++*(pucObject5);//		cc	0x79 'y'	char
						 //+		pucObject5	0x004ff56d "yfUММММММММ\x1"	unsigned char *
	cc = *(++pucObject5);//		cc	0x66 'f'	char
						 //+		pucObject5	0x004ff56e "fUММММММММ\x1"	unsigned char *
	
	//после использования реинтерпрет_каста мы получили возможность обращаться к отдельным байтам
	//длинного числа типа беззнакового инта (nObject5=0x55667788).
	stop


	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;//		nObject3	5	int
	char cObject3='A';//		cObject3	65 'A'	char
	int*	pInt = &nObject3;	//+		pInt	0x006ffbdc {5}	int *
	pVoid=&nObject3;//		pVoid	0x006ffbdc	void * совпадает с адресом pInt (адрес nObject3)
	pVoid=&cObject3;//		pVoid	0x006ffbd3	void * теперь тут адрес cObject3
	pVoid=pInt;//		pVoid	0x006ffbdc	void * снова указывает на адрес pInt
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=(static_cast<int*>(pVoid));//нужно явно привести к типу

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		const int* pn = &n;
		void const* pn1 = &n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)		pVoid	0x00d9f964	void *

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) в этом случае "наивного программиста ждет сюрприз"
											 //из-за разницы в двоичном представлении целых и чисел с плавающей точкой
											 // значение nTmp будет не 33, а совсем другое.
	stop

		//Задание 8. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель

		//Задание 8a. Указатель является константой. 
		{
		 char*  const pc1 = "ABC";;
	//	pc1  //направили указатель на строковый литерал, который доступен только для чтения в защищенном режиме
		char c1 = *pc1;//читать можно
	//	pc1++;//изменять указатель можно
		*pc1 = 'W';//изменять содержимое по адресу запрещено
		stop


		//Задание 8б. Указываемое значение является константой.
		const char c2 = 'A';
		const char * pc2 = &c2;
		//*pc2 = 'B'; //значение по указателю менять нельзя
		pc2++;// указатель можно изменять
		stop


		//Задание 8в. И указатель, и указываемое значение
		//являются константами. 
		int x = 1, y = 2;
		const int * const pn = &x;
		int z = *pn; //читать можно
		*pn = 5;//значение по указателю менять нельзя
		pn = &y;//указатель нельзя изменить
		stop


		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
		const int nN = 1;
		//Объявите указатель и проинициализируйте его выражением - &nN	
		const int* pn2 = &nN;
		//Это тот случай, когда компилятор будет не просто подставлять значение 1 везде, где встретит
		//имя n, а отведет память под такую переменную, т.к. программисту понадобился адрес этой переменной.
		stop
		}


	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	{ int	n1 = 1;

	//Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int* pn = &n1;

	//Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
	int ** ppn = &pn;

	//Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
	int *** pppn = &ppn;

	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int n2 = (*pn);
	std::cout << '\n';
	std::cout << n2;
	std::cout << '\n';

	int n3 = (**ppn);
	std::cout << n3;
	std::cout << '\n';

	int n4 = (***pppn);
	std::cout << n4;
	std::cout << '\n';
	
	stop



	}

	return 0;
}//end main
