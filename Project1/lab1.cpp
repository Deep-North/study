/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность 
	закомментированных блоков, которые требуется последовательно раскомментировать, 
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего 
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к. 
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что 
			исполняемый код будет содержать информацию для отладчика - 
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или 
		просто кликните левой кнопкой на левой серой полосе окна редактирования; 
	5. запустите программу в режиме отладки 
		(Debug/Start... или  F5);

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие 
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с 
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода

int nTwin=1;			//глобальная переменная
namespace TwinSpace{ int nTwin=2;}	//переменная объявлена в
						//пространстве имен - TwinSpace

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{

 //**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байтов, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.

	
	char cByte = 'A'; //65 в десятичной 0x41 в шестнадцатиричной
	cByte    = 0x42; // 66 0x62 'B'
	cByte    = 66;  //0x42 'B'
	cByte    = -128;   //0xff 'я'

	unsigned char ucByte = 0x41; //ucByte	0x41 'A'	unsigned char

	ucByte   = 'B'; //ucByte	0x42 'B'	unsigned char

	ucByte   =	-128; //255 0xff		ucByte	0xff 'я'	unsigned char


	int iInt =  0xffffffff; //		iInt	0xffffffff	int


	unsigned int uiInt = 0xffffffff; //		uiInt	0xffffffff	unsigned int


	float fFloat = 1.f;  //		fFloat	1.00000000	float

	double dDouble = 1.;//тип дабл

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789;// 		d	0.12345678901234568	double точности хватает на 17 разрядов
	float  f = 0.1234567890123456789123456789; //		f	0.123456791	float точности хватает на 9 разрядов, последние два знака не верные из-за особенностей представления


	d	=	1.; //		d	1.0000000000000000	double
	d	=	0.999999999999999999999999999999999; //		d	1.0000000000000000	double заносимое число больше разрядной сетки, поэтому идет округление


	stop
	
	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф';//		cw	0x0424 'Ф'	wchar_t
	size_t n = sizeof(cw); //		n	0x00000002	unsigned int т.е. 2 байта


	stop


// **************************************************************
	//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt=1;
	double dDouble1=iInt/3;		// (1)		dDouble1	0.00000000000000000	double оба значения iInt и 3 типа интежер, т.е. 1/3=0
	double dDouble2=iInt/3.;	// (2)		dDouble2	0.33333333333333331	double неявное приведение iInt в тип дабл, т.е. 1/3=0.33333333333333331
	double dDouble3 = static_cast<double>(iInt) / 3.; //явное приведение переменной iInt к типу дабл

	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble=fFloat=iInt=sShort=cByte=3.3/3;			// (1)порядок присваивания компилятором следующий:(dDouble=(fFloat=(iInt=(sShort=(cByte=(3.3/3)))))) 		dDouble	1.0000000000000000	double		fFloat	1.00000000	float		iInt	0x00000001	int		sShort	0x0001	short		cByte	0x01 '\x1'	char
	cByte=sShort=iInt=fFloat=dDouble=3.3/3;			// (2)порядок присваивания компилятором следующий:(cByte=(sShort=(iInt=(fFloat=(dDouble=(3.3/3))))))		dDouble	1.0999999999999999	double		fFloat	1.10000002	float		iInt	0x00000001	int		sShort	0x0001	short		cByte	0x01 '\x1'	char
	// компилятор ругается на потерю части данных при неявном преобразовании из одного типа в другой

	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt	=	257;//		iInt	0x00000101	int
	cByte	=	iInt; //		cByte	0x01 '\x1'	char произошло неявное преобразование типа интежер к типу байт с потерей старшего разряда из-за выхода за разрядную сетку (переменная типа чар не может быть больше 127)
	// преобразование: static_cast<byte>(iInt)

	unsigned char cN1=255, cN2=2, cSum;
	cSum = cN1 + cN2; // происходит выход за разрядную сетку. ансигнед чар имеет максимальное значение 255, а сумма чисел равна 257

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1+cN2; //выход за разрядную сетку не происходит, т.к. переменная суммы неявно приведена к типу интежер, т.е. типу с большим количеством разрядов
	//static_cast<int>(iSum)

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1=0xff, c2=2;
	unsigned char uc1=0xff, uc2=2;
	int iSum1= c1 + c2;   //(1)		iSum1	0x00000001	int. в данном случае с1 переполнилось еще при инициализации и при сложении учитывался только один байт равный 0х1111. При сложении с 0х0010, "осталось" только 0х0001, которое преобразовалось к типу нитежер как 0x00000001.
	int iSum2= uc1 + uc2; //(2)		iSum2	0x1 00000001	int. в данном случае в с1 учитывается два байта (беззнаковая величина) 0х11111111. при сложении с 0х00000010 и неявном приведении в тип интежер получается 0х00000101.

	stop

	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp=100, nn=3;
	dDouble=3.3 + nTmp / nn; // (3)		dDouble	36.299999999999997	double. Сначала получается результат от деления nTmp на nn: 33 Затем он складывается с 3.3 и неявно приводится к типу дабл. Результат 36.3

	//Получите результат без потери точности с помощью оператора явного
	//приведения типа

	//double dDouble3=3.3 + static_cast<double>(nTmp)/static_cast<double>(nn)
		


	stop


// *******************************************************
	// Задание 3. Область действия, область видимости и
	//				время существования переменных

	//   В этом фрагменте фигурируют четыре переменных с одним и тем же именем 
	// nTwin - одна глобальная, вторая определена в своем пространстве имен, 
	// (определены выше в начале модуля) третья - локальная внутри функции main(), 
	// четвертая - вложенная локальная внутри блока. 
	//   В данном задании требуется в выделенных местах фрагмента определить, к какой 
	// из четырех переменных идет обращение, а также факт существования и видимости 
	// для всех четырех, заполнив приведенные в задании таблицы 
	//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
	// Подсказка: - в окно "Watches" можно поместить как nTwin
	//			так и ::nTwin, впрочем как и TwinSpace::nTwin
	

	nTwin=100;
	TwinSpace::nTwin = 300;
	nTwin++;
	// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
	// до следующей строки еще не определена (и формально даже не существует), но место
	// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
	// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
	// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
	// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
	// Компилятор при этом все вычисляет верно.
	// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
	// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
	// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.
	int nTwin;// переменная создана, но в ней пока лежит мусор
	nTwin=200;	//		nTwin	200	int локальная
	::nTwin++;  //		::nTwin	101	int глобальная
	{
		int nTwin;//переменная создана, но в ней пока лежит мусор
		nTwin=-1;//		nTwin	-1	int локальная вложенная внутри блока
		::nTwin++;//		::nTwin	103	int глобальная
		TwinSpace::nTwin++;//		TwinSpace::nTwin	301	int из своего пространства имен
	}

	nTwin--;//		nTwin	199	int локальная переменная


// *******************************************************
	// Задание 4. Спецификатор класса памяти - static
	// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
	// б) Напишите, когда выполняется инициализация обеих переменных?
	// в) Поясните (в комментарии) разницу между способом инициализации 
	//     переменных nStatic1 и nStatic2 и поясните побочный эффект, 
	//     влияющий на переменную nLocal2.

	for (int i=0; i<3; i++)
	{
		static int nStatic1 = 100;//0) nStatic1	100	int 1) nStatic1	101	int 2) 102. здесь переменная инициализируется один раз и на все время работы программы (до следующего обращения к этому блоку)
		int nLocal1 = 100;//0) nLocal1	100	int 1) nLocal1	100	int 2) 100. Переменная инициализируется каждый раз при новой итерации цикла
		int nLocal2 = 200;//0) nLocal2	200	int 1) nLocal2	200	int 2) 200. Переменная инициализируется каждый раз при новой итерации цикла
		static int nStatic2 = nLocal2++ * 2;//0) nStatic2	400	int; nLocal2	201	int 1) nStatic2	401	int; nLocal2	200	int 2) nStatic2	402	int; nLocal2	200	int. Инициальзация выполняется только при первой итерации,т.е. эта инструкция выполняется один раз за все три итерации, соответственно, переменная nLocal2 подвергается изменению всего один раз. Этим объясняется ее значения 201,200,200.
		nStatic1++;//0) nStatic1	101	int 1) 102 2) 103. Значение переменной изменяется от итерации к итерации, т.к. это статичная переменная.
		nStatic2++;//0) nStatic2	401	int 1) 402 2) 403. Значение переменной изменяется от итерации к итерации, т.к. это статичная переменная.
		nLocal1++;//0) nLocal1	101	int 1) 101 2) 101. Значение переменной не изменяется от итерации к итерации, т.к. это локальная переменная.
		stop

	}
	// Напишите:
	//   а) как изменилось поведение пременной nStatic1?
	//   б) как эта переменная ИНИЦИАЛИЗИРОВАНА ?
	for (int i=0; i<3; i++)
	{
		static int nStatic1;// 0) 0 1) 101 2) 101
		nStatic1 = 100;// 0) 100 1) 100  2) 100
		int nLocal1 = 100;// 0) 100 1) 100 2) 100
		nStatic1++;// 0) 101 1) 101 2) 101
		nLocal1++;// 0) 101 1) 101 2) 101
		stop
			// Переменная объявляется, но не инициализируется первой инструкцией. После ей присваивается значение 100, которое сохраняется до второй итерации, где ей снова присваивается значение 100 (хотя в новую итерацию она заходит со значением 101, т.к. она статичная и ее значение сохраняется все время жизни программы).
	}



// *******************************************************
	// Задание 5. Перечисления - enum
	// Обратите внимание на явную и неявную инициализацию констант
	// Выполняя задание по шагам, следите за значениями, которые
	// принимает переменная myColors


	enum eColors
	{
		BLACK,
		BLUE,
		GREEN,
		RED=5,
		YELLOW,
		WHITE=RED+4
	};
	
	eColors   myColors;	//объявление переменной типа eColors 
	myColors=BLACK;
	myColors=BLUE;
	myColors=GREEN;
	myColors=RED;
	myColors=YELLOW;
	myColors=WHITE;

	int nnn = BLACK; //любой целочисленной переменной можно присвоить
					 //значение из списка инициализирующих значений

	//Именованные константы можно использовать в выражениях:
	nnn = BLUE | YELLOW;

	//Раскомментируйте следующую строку и обратите
	//внимание на  ошибку при компиляции || Ошибка: значение типа «int» не может быть присвоено сущности типа «eColors», значение такой переменной можно присвоить только посредством именованной константы.
	myColors = BLUE;	//модифицируйте выражение таким образом, чтобы компилятор не выдывал ошибки
	//Например, myColors = RED; или дополнить тип eColors еще одной константой, например, PURPLE, и поместить ее после WHITE. Тогда можно написать myColors = PURPLE;

	// Выполните следующее присваивание НЕ меняя перечисление и тип переменной myColors?
//	myColors = 123;
	//Здесь требуется явное приведение типа.
	myColors = static_cast<eColors>(123);
	stop


// *******************************************************
	// Задание 6.1 Логический тип bool
	// Выполняя задание по шагам, следите за значениями
	// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

	int nNumber = 1;
	bool b = (nNumber != 0); // true
	b = (nNumber == 0); // false
	b = (nNumber > 0); // true
	b = (nNumber > 1); // false
	b = 5; // true

	//Вы всегда можете преобразовать логическое значение к целому
	//явно или компилятор может это сделать самостоятельно (неявно)
	//Обратите внимание: как интерпретирует значения логических переменных компилятор?
	int tmp =  b + 1; // tmp=2, b = true = 1, т.е. 1+1=2

	//Задание 6.2 В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным не является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.
	// Примечание: НЕ НАДО пользоваться операторами if-else, тернарным оператором и switch
	//             НАДО написать логическое выражение в одну строку.
	{
		//Примеры задания года для проверки:  1823, 1900 - не високосные, 1824, 2000 - високосные
		//Вычислили значение 
		
		int year = 1900;
		bool isLeapYear = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);
		// проверили значение в отладчике
		//!(year % 400) 
		stop
	}

// *******************************************************
	// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

			//const int nN; //ошибка: нет инициализатора
			//nN = 1; //по идее, значение константы нельзя изменять, но в данном случае есть еще и "отягощение" предыдущим пунктом
			//правильно будет написать: 
		const int nN = 1;
	}



// ********************************************************
	//Задание 8. Логические условные операторы и операторы отношения.

	//Задание 8.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр (имеется ввиду регистр букв).
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует
	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	{
		// Сформируйте значение переменной ch с помощью потока ввода
		
		setlocale(LC_ALL, "Russian");
		char ch ;
		std::cout << "Введите букву: " << std::endl;
		std::cin >> ch;

		//... изменили регистр
		if (ch>='a' && ch<='z') ch=ch-0x20;//ch = ch ^ 0x20;
			else if (ch >= 'A' && ch <= 'Z') ch = ch + 0x20;
				else std::cout << "Введите букву, а не то, что вы ввели!";

		// здесь проверили в отладчике значение или вывели "эхо" на экран
		//ch = char(ch + 0x20);
		std::cout << ch << std::endl;
		system("pause");
		stop
	}


	//Задание 8.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику:
	//если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		double x, y;
		setlocale(LC_ALL, "Russian");
		std::cout << "Введите X: " << std::endl;
		std::cin >> x;
		if (x<=0) y=0 ;
			else if (x>=1) y=1;
				else y = x;
		std::cout << y << std::endl;
		system("pause");
		stop
	}

	//Задание 8.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: в переменной cInput типа char дано значение символа,
	//введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	{
		int x=10, y;
		char cInput;
		//сформировали значение
		setlocale(LC_ALL, "Russian");
		std::cout << "Введите символ: " << std::endl;
		std::cin >> cInput;
		
		switch (cInput)
		{
		case 'Y':
		case 'y':
			y = x;
			std::cout << "y = " << y << std::endl;
			break;
		case 'N':
		case 'n':
			y = x * 2;
			std::cout << "y = " << y << std::endl;
			break;
		default:
			std::cout << "ОШИБКА! Введите Y или N" << std::endl;
		}
		system("pause");
		stop
	}
	// ********************************************************
	//Задание 9. Циклы.

	//Задание 9.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Введите границы с помощью потока ввода или с помощью средств отладки.
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	{
		
		//сформировать границы диапазона
		int iGran1, iGran2, iTmp;
		setlocale(LC_ALL, "Russian");
		std::cout << "Введите нижнюю границу диапазона (целое число)): " << std::endl;
		std::cin >> iGran1;
		std::cout << "Введите верхнюю границу диапазона (целое число): " << std::endl;
		std::cin >> iGran2;
		
		//проверить корректность значений
		if (iGran1 > iGran2) { iTmp = iGran1; iGran1 = iGran2; iGran2 = iTmp; };

		// вычислить сумму
		int iSum = 0;
		for (int i = iGran1; i <= iGran2; i++)
		{
			iSum += i;
		}

		// проверить в отладчике значение
		std::cout << "Сумма диапазона равна: " << iSum << std::endl;
		system("pause");
		stop
	}


	//Задание 9.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.
	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.
	
	{
		setlocale(LC_ALL, "Russian");
		int iCh;
		do { std::cout << "Введите целое число: " << std::endl;
		std::cin >> iCh;
		} while((iCh<10) || (iCh & 1));
	}

	//Задание 9.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	{
		int x=0;
		double sum = 0;
		while (sum<=1.7)
		{
			x = x + 1;
			sum = sum + 1. / x;
		}
	}
	return 0;//код завершения приложения
}	// Конец функции main()

