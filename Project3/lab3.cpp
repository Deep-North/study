/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


#define	  stop __asm nop
#include <iostream>
#include <cstdlib>
#include <time.h>
#include <string>

int main()
{
	setlocale(LC_ALL, "Russian");

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////

	//Задание 1. Объявите трехмерный массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	{
		int ar1[3][3][3] = { 1,2,3,4,5,6,7,8,9 };
		stop
	}
		//б) объявите неинициализированный массив и присвойте значения элементам
		//	с помощью кода
		//					 |--------|		
		//				   / |3  3  3 |		
		//    			 |---------|3 |
		//			   / | 2  2  2 |3 |
		//			  |---------|2 |__|
		//			  | 1  1  1 |2 | /
		//			  | 1  1  1 |__| 
		//			  | 1  1  1 | /
		//			  |_________|
		//Средствами отладчика проверьте правильность Вашего решения.
	{
		setlocale(LC_ALL, "Russian");
		std::cout << "Задание 1.Б";
		std::cout << '\n';
		int x = 1;
		int ar2[3][4][6];
		int n = sizeof(ar2[0][0]) / sizeof(int);
		std::cout << n;
		int m = sizeof(ar2[0]) / sizeof(ar2[0][0]);
		std::cout << m;
		int o = sizeof(ar2) / sizeof(ar2[0]);
		std::cout << o;
		std::cout << '\n';
		std::cout << '\n';
		for (int i = 0; i < o; i++)
		{
			for (int j = 0; j < m; j++)
			{
				for (int k = 0; k < n; k++)
				{
					ar2[i][j][k] = i+1;
					std::cout << ar2[i][j][k];
					//std::cout << '\n';
				}
				std::cout << '\n';
				//x++;
			}
			std::cout << '\n';
			//x++;
		}
		stop
	}
		
	
	
	
	
	//в) найдите сумму элементов массива
	{
		
		setlocale(LC_ALL, "Russian");
		std::cout << "Задание 1.В";
		std::cout << '\n';
		int sum = 0;
		int ar2[3][3][3];
		int n = sizeof(ar2[0][0]) / sizeof(int);
		std::cout << n;
		int m = sizeof(ar2[0]) / sizeof(ar2[0][0]);
		std::cout << m;
		int o = sizeof(ar2) / sizeof(ar2[0]);
		std::cout << o;
		std::cout << '\n';
		std::cout << '\n';
		int* p = ar2[0][0];
		for (int i = 0; i < sizeof(ar2) / sizeof(int); i++)
		{
			sum += *(p + i);
			//i += sizeof(int);
		}
		for (int i = 0; i < o; i++)
		{
			for (int j = 0; j < m; j++)
			{
				for (int k = 0; k < n; k++)
				{
					ar2[i][j][k] = i + 1;
					std::cout << ar2[i][j][k];
					sum += ar2[i][j][k];
				}
				std::cout << '\n';
			}
			std::cout << '\n';
		}
		std::cout << '\n';
		std::cout << sum;
		std::cout << '\n';
		std::cout << '\n';
		stop
	}
		//г) проинициализируйте массив при объявлении:
		//					 |--------|		
		//				   / |3  0  0 |		
		//    			 |---------|0 |
		//			   / | 2  0  0 |0 |
		//			  |---------|0 |__|
		//			  | 1  0  0 |0 | /
		//			  | 0  0  0 |__| 
		//			  | 0  0  0 | /
		//			  |_________|
	
	{
		setlocale(LC_ALL, "Russian");
		std::cout << "Задание 1.Г";
		std::cout << '\n';
		int ar3[3][3][3] = { {1},{2},{3} };

		int n = sizeof(ar3[0][0]) / sizeof(int);
		std::cout << n;
		int m = sizeof(ar3[0]) / sizeof(ar3[0][0]);
		std::cout << m;
		int o = sizeof(ar3) / sizeof(ar3[0]);
		std::cout << o;
		std::cout << '\n';
		std::cout << '\n';

		for (int i = 0; i < o; i++)
		{
			for (int j = 0; j < m; j++)
			{
				for (int k = 0; k < n; k++)
				{
					std::cout << ar3[i][j][k];
				}
				std::cout << '\n';
			}
			std::cout << '\n';
		}
		std::cout << '\n';
		stop
	}


		//д) Инициализация массивов строковыми литералами:
		//Объявите и проинициализируйте строковыми литералами два массива:
		//двухмерный массив и массив указателей. Поясните разницу в использовании
		//элементов таких массивов.
	{
		setlocale(LC_ALL, "Russian");
		std::cout << "Задание 1.Д";
		std::cout << '\n';
		char ar4[][10] = {"One", "Two", "Three", "Four"};
		//компилятор выделяет место в статической памяти для хранения строк,
		//выделяет память 4*10*sizeof(char),
		//копирует содержимое строковых литералов в соответствующие строки массива.

		const char* ar5[]= { "One", "Two", "Three", "Four" };
		//компилятор выделяет место в статической памяти для хранения строк,
		//выделяет память под четыре указателя для одномерного массива,
		//присваивает каждому элементу массива значение, равное адресу начала
		//соответствующего строкового литерала.
		std::cout << ar4[0][0];
		std::cout << ar5[0][0];
		ar4[0][0] = 'Z';
		//ar5[0][0] = 'Z';
		std::cout << "\n\n\n\n";
		stop
	}


///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание2. Создайте динамический двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	{
		int N = 5, M = 5;
		int Sum = 0;
		srand(time(0));
		int **dynamic_array = new int*[N];
		for (int i = 0; i < N; i++)
		{
			dynamic_array[i] = new int[M];
		}
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				dynamic_array[i][j] = (rand() % 100);
				Sum += dynamic_array[i][j];
				std::cout << "p=";
				std::cout << dynamic_array[i][j];
				std::cout << " Sum=";
				std::cout << Sum;
				std::cout << "    ";
			}
			std::cout << '\n';
		}
		std::cout << '\n';
		std::cout << '\n';
		std::cout << "Sum=";
		std::cout << Sum;
		std::cout << "\n\n\n\n";
		stop


//еще раз выведу массив
			std::cout << "Массив:\n\n";
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M; j++)
				{
					std::cout << "  p=";
					std::cout << dynamic_array[i][j];
				}
				std::cout << '\n';
			}
		std::cout << "\n\n";
		stop



			//Задание2а. В сформированном массиве отсортируйте каждую строку по
			//убыванию значений. Используйте сортировку "выбором"
			
			for (int i = 0; i < N; i++)
			{
				for (int j = 0; j < M-1; j++)
				{
					int max = j;
					for (int k = j + 1; k < M; k++)// внутренний цикл - поиск наибольшего из оставшихся значений
					{
						if (dynamic_array[i][k] > dynamic_array[i][max]) max = k;
					}
						int tmp = dynamic_array[i][max];
						dynamic_array[i][max] = dynamic_array[i][j];
						dynamic_array[i][j] = tmp;				
				}
			}


//вывод для проверки
		std::cout << "Отсортированный массив:\n\n";
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << "  p=";
				std::cout << dynamic_array[i][j];
				//std::cout << '\n';
			}
			std::cout << '\n';
		}
		std::cout << '\n';
		std::cout << '\n';
		stop

			//Задание2б. Объявите одномерный массив размерностью N.
			//Сформируйте значение i-ого элемента одномерного массива  
			//равным среднему значению элементов i-ой строки
			//двухмерного массива

		int* Mas1 = new int[M];
		for (int i = 0; i < N; i++)
		{
			Sum = 0;
			for (int j = 0; j < M; j++)
			{
				Sum += dynamic_array[i][j];
			}
			Sum = (Sum / M);
			Mas1[i] = Sum;
		}

		for (int i = 0; i < N; i++)
		{
			std::cout << Mas1[i];
			std::cout << " ";
		}
		stop

		//Подсказка - не забудьте освободить память!

		for (int i = 0; i < N; i++)
		{
		delete[] dynamic_array[i];
		}
		delete[] dynamic_array;
		dynamic_array = 0;

		delete[] Mas1;
		Mas1 = 0;

		std::cout << "\n\n";
		stop
	}
	
	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
	
	std::cout << "Задание 3.а\n";
	int ar31[10];
	size_t n = sizeof(ar31) / sizeof(ar31[0]);
	for (int i = 0; i < n; i++)
	{
		std::cout << "Введите целое число: \n";
		std::cin >> ar31[i];
		for (int j = 0; j < i; j++)// внешний цикл задает количество итераций
		{
			int min = j;
			for (int k = j; k <= i; k++)
				{
					if (ar31[k] < ar31[min]) min = k;
				}
			int tmp = ar31[min];
			ar31[min] = ar31[j];
			ar31[j] = tmp;
		}
		for (int l = 0; l <= i; l++)
		{
			std::cout << ar31[l];
			std::cout << " ";
		}
		std::cout << '\n';
	}
	std::cout << "\n\n";
	stop


	//б) Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:очередное значение
	//вводится в массив только при условии, что там еще такого нет (то есть 
	//дубли игнорируются

	std::cout << "Задание 3.б\n";
	int ar32[1];
	size_t n1 = sizeof(ar32) / sizeof(ar32[0]);
	int tmpint;
	for (int i = 0; i < n1; i++)
	{
		std::cout << "Введите целое число: \n";
		std::cin >> tmpint;
		bool priznak = true;

		for (int m = 0; m <= i; m++)
		{
			if (ar32[m] == tmpint) priznak = false;
		}

		if (priznak)
		{
			ar32[i]=tmpint;
			for (int j = 0; j < i; j++)// внешний цикл задает количество итераций
			{
				int min = j;
				for (int k = j; k <= i; k++)
				{
					if (ar32[k] < ar32[min]) min = k;
				}
				int tmp = ar32[min];
				ar32[min] = ar32[j];
				ar32[j] = tmp;
			}
		}
		else
		{
			std::cout << "Такое число вы уже вводили. Введите еще раз: \n";
			i--;
		}
		for (int l = 0; l <= i; l++)
		{
			std::cout << ar32[l];
			std::cout << " ";
		}
		std::cout << '\n';
	}
	std::cout << "\n\n";
	stop


	{
		///////////////////////////////////////////////////////////////////////////
		//Задание 4.С помощью данной заготовки напишите программу,
		//которая:
		//вводит строки с клавиатуры с помощью cin>>...
		//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
		//признаком конца ввода является символ * (то есть строка - "*") или
		//заполнение массива (больше свободных строк нет);
		//сортировка строк в алфавитном порядке. Пояснение: крайне
		//не рекомендуется для сортировки сложных объектов физически
		//перемещать их в памяти. Намного эффективнее завести массив
		//указателей на соответствующие строки и перемещать только
		//указатели.

		//Подсказка: для лексиграфического сравнения строк пользуйтесь
		//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.

	
		//Определите необходимые значения как константы
		char STOP_STRING[] = "*";	//признак "прекратить ввод"
		const int M = 80;	//максимальный размер одной строки
		const int N = 10;	//максимальное количество строк в массиве

		//Объявите двухмерный массив с именем cBuffer типа char и
		// размерностью N*M
		char cBuffer[N][M];

		//Объявите массив (с именем cPointers) указателей на строки
		//размерностью N
		char* cPointers[N];
		//for (int i = 0; i < N; i++) cPointers[i] = cBuffer[i];

		//Вспомогательные переменные
		int counter = 0;
		int nIndex = 0;
		char* p;
		
		//Цикл ввода строк:
		//а) выведите приглашение для ввода
		std::cout << "Задание 4. \n\nВведите 10 строк. Если хотите закончить раньше, введите *:\n\n";
		
		//б) пока не введена строка STOP_STRING или не заполнен весь массив
		do
			//ввод строки в массив cBuffer:
		{
			std::cin >> cBuffer[counter];
			counter++;
		//если введена строка - признак окончания, то выйти из цикла
		} while ((strcmp(cBuffer[counter-1], STOP_STRING)!=0) && counter < N);
		
		//Присвойте элементу массива cPointers с индексом nIndex
		//указатель на строку с номером nIndex в массиве cBuffer
		for (nIndex = 0; nIndex <= counter; nIndex++)
		{
			//cPointers[nIndex] = cBuffer[(nIndex*80*sizeof(char))];
			cPointers[nIndex] = cBuffer[nIndex];
		}
		//Выдать диагностику о том, что прием строк завершен.
		std::cout << "\n\nПрием строк завершен.\n\n";
		
		//Теперь сортируем строки:
		//Сначала выведем массив:
		std::cout << "Наш массив строк.\n\n";
		for (int i = 0; i < counter; i++)
		{
			std::cout << cBuffer[i];
			std::cout << '\n';
		}

		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания. На каждой итерации - промежуточная печать 
		//отсортированных строк
		
			for (int i = 0; i < counter; i++)
			{
				int min = i;
				for (int j = i+1; j < counter; j++)
				{
					if (strcmp(cPointers[j], cPointers[min]) < 0) min = j;
				}
				p = cPointers[min];
				cPointers[min] = cPointers[i];
				cPointers[i] = p;
				std::cout << "\nПромежуточный вывод строк.\n";
				for (int i = 0; i < counter; i++)
				{
					std::cout << cPointers[i];
					std::cout << '\n';
				}
			}
	stop
	}

	{
	//Задание 5. Реализуйте задание №4, используя не встроенные,
	//а динамические массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	int nStringNumber;
	int row_counter=0;
	char STOP_STRING[] = "*";
	int dlina_stroki;
	char* p;

	std::cout << "====================================================================";
	std::cout << "\nЗадание 5.\n\nВведите количество строк:\n";
	std::cin >> nStringNumber;
	
	char tmp_string[100];
	
	char** ar5 = new char*[nStringNumber];

	//Цикл ввода строк:

	do {
		std::cout << "Введите строку:\n";
		std::cin >> tmp_string;						//буферная переменная
		dlina_stroki = (strlen(tmp_string) + 1);	//вычисляем длину буферной строки
		ar5[row_counter] = new char[dlina_stroki];	//динамически выделяем память под строку массива
		for (int i = 0; i < dlina_stroki; i++)
		{
			ar5[row_counter][i] = tmp_string[i];	//копируем буфер в строку массива
		}
		row_counter++;
	} while ((strcmp(tmp_string, STOP_STRING) != 0) && (row_counter < nStringNumber));

	//Вывод массива для проверки
	std::cout << "\n";
	for (int i = 0; i < row_counter; i++)
	{
		std::cout << ar5[i];
		std::cout << '\n';
	}


	//Цикл сортировки строк методом "всплывающего пузырька" в
	//порядке возрастания кода первого символа
	for (int i = 0; i < row_counter; i++)
	{
		int min = i;
		for (int j = i + 1; j < row_counter; j++)
		{
			if (strcmp(ar5[j], ar5[min]) < 0) min = j;
		}
		p = ar5[min];
		ar5[min] = ar5[i];
		ar5[i] = p;
		std::cout << "\nПромежуточный вывод строк.\n";
		for (int i = 0; i < row_counter; i++)
		{
			std::cout << ar5[i];
			std::cout << '\n';
		}
	}
		
	//Освобождение занятой памяти:
	for (int i = 0; i < row_counter; i++)
	{
		delete[] ar5[i];
	}
	delete[] ar5;
	ar5 = 0;

	std::cout << "====================================================================\n\n";
	stop
	}


	{
		//Задание 6. Объявление и использование указателей на многомерные
		// массивы. Проинициализируйте трехмерный массив
		//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
		//кода, который меняет местами значения элементов четных
		//и нечетных слоев:
		//	было:			     |--------|		
		//  				   / |4  4  4 |		
		//					 |--------|	4 |	
		//				   / |3  3  3 |	4 |	
		//    			 |---------|3 |   |
		//			   / | 2  2  2 |3 | /
		//			  |---------|2 |__|
		//			  | 1  1  1 |2 | /
		//			  | 1  1  1 |__| 
		//			  | 1  1  1 | /
		//			  |_________|

		//	стало:			     |--------|		
		//  				   / |3  3  3 |		
		//					 |--------|	3 |	
		//				   / |4  4  4 |	3 |	
		//    			 |---------|4 |   |
		//			   / | 1  1  1 |4 | /
		//			  |---------|1 |__|
		//			  | 2  2  2 |1 | /
		//			  | 2  2  2 |__| 
		//			  | 2  2  2 | /
		//			  |_________|


		double dArray[4][3][3];
		for (int i = 0; i < 4; i++)
			for (int j=0; j<3; j++)
				for (int k = 0; k < 3; k++)
				{
					dArray[i][j][k] = i+1;
				}

		//Вывод массива для проверки
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				for (int k = 0; k < 3; k++)
				{
					std::cout << dArray[i][j][k];
				}
				std::cout << '\n';
			}
		}
		std::cout << "\n\n\n";

		//double temp_ar[3][3]; //вспомогательный массив в один слой 3х3

		{
			//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
			double(*p)[3][3] = dArray;
			double tmp;
			double(*p1)[3]=0;
			double(*p2)[3]=0;
			//переставляем местами элементы i-того и i+1-ого слоев
			for (int i = 0; i < 3; i=i+2)
			{
				p1 = dArray[i];
				p2 = dArray[i + 1];
				for (int j = 0; j < 9; j++)
				{
					tmp = *(*p1+j);
					*(*p1+j) = *(*p2+j);
					*(*p2+j) = tmp;
				}
			}
			
			//Вывод массива для проверки
			for (int i = 0; i < 4; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					for (int k = 0; k < 3; k++)
					{
						std::cout << dArray[i][j][k];
					}
					std::cout << '\n';
				}
			}
		}
		std::cout << "====================================================================\n\n";
		stop
	}

	{
		///////////////////////////////////////////////////////////////////////////
		//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
		//Сформируйте значения элементов массива с помощью генератора случайных 
		//чисел таким образом, чтобы в массиве были только символы '*' и '_'  


		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"
		std::cout << "====================================================================\n\nЗадание 7A.\n\n";
		const int N = 10, M = 20;
		char cMass1[N][M];
		char tmpMass[N][M];

		srand(time(0));
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				if (rand() & 1)	cMass1[i][j] = '*';
				else cMass1[i][j] = '_';
			}
		}
		
		//Вывод массива для проверки
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << (cMass1[i][j]) << " ";
			}
			std::cout << '\n';
		}
		std::cout << '\n';

		//Сдвигаем звездочки
		
		for (int i = 0; i < N; i++)
		{
			int q = 0;
			for (int j = 0; j < M; j++)
			{
				if (cMass1[i][j] == '*')	tmpMass[i][j] = '*';
				else
				{
					//tmpMass[i][(M - j)] = '_';
					tmpMass[i][j] = '*';
					q++;
				}
			}
			for (int k = M-1; k >= (M-q); k--)
			{
				tmpMass[i][k] = '_';
			}
		}
		//Вывод массива для проверки
		std::cout << "___________________\n";
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << (tmpMass[i][j]) << " ";
			}
			std::cout << '\n';
		}
		std::cout << '\n';
		
	stop
	}
	{
		// 7б. Модифицируйте предыдущее задание следующим способом:
		//После заполнения массива с помощью генератора случайных чисел
		//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
		//"распределение"

		std::cout << "====================================================================\n\nЗадание 7B.\n\n";
		const int N = 10, M = 10;
		char cMass1[N][M];
		char tmpMass[N][M];

		srand(time(0));
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				if (rand() & 1)	cMass1[i][j] = '*';
				else cMass1[i][j] = '_';
			}
		}

		//Вывод массива для проверки
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << (cMass1[i][j]) << " ";
			}
			std::cout << '\n';
		}
		std::cout << '\n';

		//Сдвигаем звездочки

		for (int i = 0; i < M; i++)
		{
			int q = 0;
			for (int j = 0; j < N; j++)
			{
				if (cMass1[j][i] == '_')	tmpMass[j][i] = '_';
				else
				{
					//tmpMass[i][(M - j)] = '_';
					tmpMass[j][i] = '_';
					q++;
				}
			}
			for (int k = M - 1; k >= (M - q); k--)
			{
				tmpMass[k][i] = '*';
			}
		}
		//Вывод массива для проверки
		std::cout << "__________________\n";
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				std::cout << (tmpMass[i][j]) << " ";
			}
			std::cout << '\n';
		}
		std::cout << '\n';

		stop
	
	}
	return 0;

}