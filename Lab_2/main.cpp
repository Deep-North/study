// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.


#include <tchar.h>
#include <iostream>
#include "Circle.h"
#include "Rect2.h"
#include "MyByte.h"
#define	  stop __asm nop

int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "Russian");
//
//	//Задание 1.Простое наследование.Аргументы конструктора,
//	// передаваемые в базовый класс.
//
//	//Создайте иерархию классов:
//	//базовый класс Shape (который описывает любую фигуру)
//	//и два производных класса Rect и Circle.
//	//Подумайте: какие данные и методы нужно ввести в базовый
//	//и производные классы (например, любую фигуру можно сделать
//	//цветной => в базовом классе можно ввести переменную, которая
//	//будет определять цвет фигуры.
//	//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);
//	std::cout << "===========================================================\nЗадание 1.\n";
//	Circle c(1, 2, 10, Shape::BLUE);
//	c.Print_Circle();
//	//std::cout << c.GetColor() << "\n";
//
//	Rect2 r(1, 2, 3, 4, Shape::GREEN);
//	//std::cout << r.GetColor() << "\n";
//	
//	//В конструкторах производных классов предусмотрите передачу
//	//параметра-цвета конструктору базового класса.
//	//При создании и уничтожении объекта производного типа определите
//	//последовательность вызовов конструкторов и деструкторов базового
//	//и производного классов
//	
//
//
//
//	stop
////////////////////////////////////////////////////////////////////////
//
//	//Задание 2.Виртуальные функции.
//	//2а) Модифицируйте классы Shape,Rect и Circle:
//	//добавьте в каждый класс public метод void WhereAmI().
//	//Реализация каждой функции должна выводить сообщение 
//	//следующего вида "Now I am in class Shape(Rect или Circle)".
//	//Выполните приведенный фрагмент, объясните результат.
//	std::cout << "===========================================================\nЗадание 2.A\n";
//
//	{
//		Shape s;
//		Rect2 r(1, 2, 3, 4, Shape::GREEN);
//		Circle c(1, 2, 10, Shape::BLUE);
//
//	
//		//Метод какого класса вызывается в следующих строчках???
//		s.WhereAmI();	//	Now I am in class Shape
//		r.WhereAmI();	//	Now I am in class Rect2
//		c.WhereAmI();	//	Now I am in class Circle
//		stop
//
//
//		Shape* pShape = &s;
//		Shape* pRect = &r;
//		Shape* pCircle = &c;
//	   	pShape->WhereAmI();		//	Now I am in class Shape
//		pRect->WhereAmI();		//	Now I am in class Shape
//		pCircle->WhereAmI();	//	Now I am in class Shape
//		stop
//
//		//Заполните ... согласно комментариям
//		Shape& rShape = s;		//псевдоним s
//		Shape& rRect = r;		//псевдоним r
//		Shape& rCircle = c;		//псевдоним c
//		rShape.WhereAmI();			//вызов посредством rShape	Now I am in class Shape
//		rRect.WhereAmI();			//вызов посредством	rRect	Now I am in class Shape
//		rCircle.WhereAmI();			//вызов посредством rCircle	Now I am in class Shape
//	}
//
//
//	//2б) Сделайте метод WhereAmI() виртуальным.
//	//Снова выполните приведенный фрагмент, объясните разницу.
//	std::cout << "===========================================================\nЗадание 2.Б\n";
//	{
//		Shape s;
//		Rect2 r(1, 2, 3, 4, Shape::GREEN);
//		Circle c(1, 2, 10, Shape::BLUE);
//
//
//		//Метод какого класса вызывается в следующих строчках???
//		s.WhereAmI();	//	Now I am in class Shape
//		r.WhereAmI();	//	Now I am in class Rect2
//		c.WhereAmI();	//	Now I am in class Circle
//		stop
//
//
//		Shape* pShape = &s;
//		Shape* pRect = &r;
//		Shape* pCircle = &c;
//		pShape->WhereAmI();		//	Now I am in class Shape
//		pRect->WhereAmI();		//	Now I am in class Rect2
//		pCircle->WhereAmI();	//	Now I am in class Circle
//		stop
//
//		//Заполните ... согласно комментариям
//		Shape& rShape = s;		//псевдоним s
//		Shape& rRect = r;		//псевдоним r
//		Shape& rCircle = c;		//псевдоним c
//		rShape.WhereAmI();			//вызов посредством rShape	Now I am in class Shape
//		rRect.WhereAmI();			//вызов посредством rRect	Now I am in class Rect2
//		rCircle.WhereAmI();			//вызов посредством	rRect	Now I am in class Circle
//	
//	//вероятно различие вызвано тем, что виртуальные методы заносятся в таблицу виртуальных методов и вызываются оттуда
//	}
//stop
//
////////////////////////////////////////////////////////////////////////
//
//	{
//	//Задание 3.Виртуальные деструкторы.
//	std::cout << "===========================================================\nЗадание 3.\n";
//	//Модифицируйте классы:
//	//a) введите соответствующие
//	// деструкторы (без ключевого слова virtual).
//	//Реализация каждого деструктора
//	//должна выводить сообщение следующего вида
//	// "Now I am in Shape's destructor!" или
//	// "Now I am in Rect's destructor!"
//	//Выполните фрагмент. Объясните результат.
//
//	Rect2 r (10, 20, 30, 40, Shape::GREEN);
//	Shape* ar[] = { new Shape(r), new Rect2(r), new Circle(r), new Circle() };
//	//Вызовите для каждого элемента массива метод WhereAmI()
//	for (int i = 0; i < sizeof(ar) / sizeof(ar[0]); i++)
//	{
//		ar[i]->WhereAmI();
//		delete ar[i];
//	}
//	stop
//	// b) Добавьте в объявление деструкторов ключевое слово virtual 
//	//Выполните фрагмент.Объясните разницу.
//
//	
//	//Подумайте: какие конструкторы вызываются в следующей строке?
//		//Если в разработанных классах каких-то конструкторов
//		//не хватает - реализуйте
//		//Если Вы считаете, что в приведенном фрагменте чего-то
//		//не хватает - добавьте
//
//		Rect2 r2(10, 20, 30, 40, Shape::GREEN);
//		Shape* ar2[]={new Shape(r2), new Rect2(r2), new Circle(r2), new Circle() };
//		//Вызовите для каждого элемента массива метод WhereAmI()
//		for (int i = 0; i < sizeof(ar2) / sizeof(ar2[0]); i++)
//		{
//			ar2[i]->WhereAmI();
//			delete ar2[i];
//		}
//	//конструктор/деструктор: 1)shape/shape 2)rect/rect-shape 3)circle/circle-shape 4)circle/circle-shape
//	stop
//	}
//
//
	//Задание 4*. В чем заключается отличие 1) и 2)
	{
	std::cout << "===========================================================\nЗадание 4.\n";
		Shape* pShapes = new Rect2[10];	//1)
		Rect2* pRects = new Rect2[10];	//2)
		std::cout << "\n";
		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???
		Rect2 * pTmp = static_cast<Rect2*>(pShapes);
	for(int i = 0; i < 10; i ++) {
		//Rect2 * pTmp = static_cast<Rect2*>(pShapes);
		pTmp[i].WhereAmI();
		//((pShapes) + i)->WhereAmI();					//Now I am in class Shape (если убрать virtual)
														//Если не убирать, то будет Now I am in class Rect2
		pRects[i].WhereAmI();							//Now I am in class Rect2
	}
		//Причина в создании таблицы адресов функций, если метод объявлен вирутальный, и он реализован в 
		//потомке, то он добавляется первым в таблицу методов, иначе берется объект метод родителя

		//Освободите динамически захваченную память
		delete[] pRects;
		delete[] pShapes;
		stop
	}

//вызвать вэрэмай в каждом случае. Желательно в каждом своем цикле.
//*(pShapes+0) *(pShapes+1), а у нас массив из ректов (цикл).
//показать это все тут


////////////////////////////////////////////////////////////////////////
//
//	//Задание 5.Виртуальные функции и оператор разрешения области видимости. 
//
//	{
//		std::cout << "===========================================================\nЗадание 5.\n";
//		Rect2 r(10, 20, 30, 40, Shape::GREEN);
//		Shape* p = &r;
//		p->WhereAmI();//...Now I am in class Rect2
//		stop
//	
//			std::cout << "===========================================================\nЗадание 5.a\n";
//		//5a Оператор разрешения области видимости.
//		//Посредством объекта r и указателя p вызовите виртуальную функцию
//		//WhereAmI()класса Shape
//		p->Shape::WhereAmI();			//Now I am in class Shape
//	stop	
//	}
//

//////////////////////////////////////////////////////////////////////

	//Задание 6.Чисто виртуальные функции. 
	//Введите в базовый класс метод void Inflate(int); Подумайте:
	//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
	//Реализуйте этот метод для производных классов.
	{
		std::cout << "===========================================================\nЗадание 6.\n";
		Rect2 r(10, 20, 30, 40, Shape::GREEN);
		Shape* p = &r;
		p->Inflate(5);
		Circle c(1,2,10, Shape::RED);
		p = &c;
		p->Inflate(5);
	}


//////////////////////////////////////////////////////////////////////

	{
	std::cout << "===========================================================\nЗадание 7.\n";
	//Задание 7.Объединения (union) C++. Битовые поля.
	//1.
	//Создайте следующие классы для различных представлений значений байта:
	//Bin - для двоичного представления
	//Hex - для шестнадцатерчного представления
	//Oct - для восьмеричного представления.
	//Подсказка 1: - для удобства используйте битовые поля.
	//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
	//так как все они будут членами объединения (union).
	//2.
	//В каждом классе введите метод Show, который должен выводить значение в
	//соответствующем виде
	//3.
	//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
	//одним и тем же значением по-разному:
	//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта 
	//          а также символ, соответствующий хранимому значению (если есть соответствие);
	//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
	//			восьмеричные, двоичные цифры;
	//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

	MyByte byte(0x1f);

	byte.ShowDec();
	byte.ShowHex();
	byte.ShowOct();
	byte.ShowBin();

	byte.ShowBinPos(4);
	byte.ShowOctPos(2);
	byte.ShowHexnPos(1);

	byte.EditBin(5, 0);
	byte.ShowHex();
	byte.ShowOct();
	byte.ShowBin();

	byte.EditHex(2, 0xF);
	byte.ShowHex();
	byte.ShowOct();
	byte.ShowBin();

	byte.EditOct(2, 0);
	byte.ShowHex();
	byte.ShowOct();
	byte.ShowBin();

	stop
	}

	return 0;
}//endmain

