#include "myRect.h"
#include "myString.h"
#include "Bochka.h"
#include <iostream>

#define stop __asm nop

void main()
{
using namespace std;
setlocale(LC_ALL, "Russian");

	
//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
std::cout << "===========================================================\nЗадание 1.\n";
	{
		Rect rect1();
		stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	Rect rect2(301, 20, 101, 20);
	stop
	//1б. При конструировании объекта посредством конструктора без параметров
	//предусмотрите инициализацию переменных класса, например, нулем

	Rect rect3;
	stop

	//1в. Подумайте, как следует поступать в случае, когда пользователь задал
	//координаты следующим образом:

	Rect rrr(4,3,2,1); //ввел функцию Normalize
	stop
	
	//1г. Объявите, определите и вызовите метод класса InflateRect(), 
	//который увеличивает размеры прямоугольника на заданные приращения
	//(раздвигая стороны от центра - каждую сторону на свое значение).
	//Подсказка: объявить и определить методы можно не только "вручную",
	//но и с помощью Wizard-a Class View. Для этого: откройте закладку
	//ClassView окна проекта, сделайте активным класс Rect и нажмите
	//правую кнопку мыши - в появившемся контекстном меню выберите
	//Add/Add Member Function... С помощью появившейся диалоговой панели
	//"дайте указания" Wizard-у как объявить и определить метод.
	
	stop


	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.
		std::cout << "\n===========================================================\nЗадание 2.\n";
	//2а.Объявите и определите конструктор копирования в классе Rect.
	//Выполняя задание по шагам, определите, какой
	//конструктор вызывается при создании r1,r2,r3 и r4?
	//Чему равны переменные созданных объектов?
		std::cout << "\n\nr1: ";
		Rect r1;//default-конструктор
		std::cout << "r2: ";
		Rect r2(1,2,3,4);//мною определенный конструктор копирования
		std::cout << "r3: ";
		Rect r3 = r1;//конструктор автоматического копирования (нормальная форма записи)
		std::cout << "r4: ";
		Rect r4(r2);//то же самое, но функциональная форма записи
		
		stop


  //2б. Объявите и определите в классе Rect метод InflateRect(),
	//который принимает два аргумента, по умолчанию равных 1, и 
	//раздвигает стороны прямоугольника на заданные приращения.
	//Для каких объектов вызывается функция InflateRect()?
		std::cout << "\nr1: ";
		r1.InflateRect(1,1);
		std::cout << "\nr2: ";
		r2.InflateRect(2,2);
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		std::cout << "\nr3: ";
		r3.InflateRect(2,2,2,2);
		std::cout << "\nr3: ";
		r3.InflateRect(3,3);
		std::cout << "\nr3: ";
		r3.InflateRect(5);
		std::cout << "\nr3: ";
		r3.InflateRect();
	stop



	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
std::cout << "===========================================================\nЗадание 3.\n";
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//int tmp = r.m_left;
	
	//Error	C2248	'Rect::m_left': cannot access private member declared in class 'Rect'
	//Член класса m_left не находится в "публичной" области, т.е. доступа к нему нет.


	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 

	r3.SetAll(11, 22, 33, 44);
	std::cout << "\n";

	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 

	int left1=0, right1=0, top1=0, bottom1=0;
	std::cout << "Исходные значения: " << left1 << " " << right1 << " " << top1 << " " << bottom1;
	r3.GetAll(left1, right1, top1, bottom1);
	std::cout << "Извлеченные значения: " << left1 << " " << right1 << " " << top1 << " " << bottom1;
	stop
	}


	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom
	std::cout << "\n\n===========================================================\nЗадание 4.\n";
	{

	Rect r1(1,2,3,4), r2(5,6,7,8),r3;
	r3 = BoundingRect(r1, r2);
	stop

	//Задание 4а. Передача объектов по ссылке.
	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
	//задачу, принимая параметры по ссылке
	//Вызываются ли конструкторы при передаче параметров?
	
	std::cout << "\n\n===========================================================\nЗадание 4.A.\n";
	r3 = BoundingRect2(r1, r2);
	stop
	}




	//Задание 5. Указатель на класс. Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		std::cout << "\n\n===========================================================\nЗадание 5.\n";
		Rect r11;							//Конструктор r11 0,0,0,0
		Rect*	pR = new Rect(1,2,1,2);		//Конструктор pR 1,2,1,2
		{
			Rect r22(r11);					//Конструктор копирования		r2
			Rect arRect[2];					//Два коструктора				arRect 0,0,0,0 и 0,0,0,0
			for(int i=0; i<3; i++)
			{
				static Rect r33 (i,i,i,i) ;	//1)Конструктор	r33 0,0,0,0						2,3)ничего?
				Rect r44(*pR);				//1)Конструктор копирования r44	1,2,1,2			2,3)Конструктор копирования 1,2,1,2
				Rect r55(i,i,i,i);			//1)Конструктор r55 0,0,0,0						2,3)Конструктор 1,1,1,1 (2,2,2,2)
			}								//1)После первого цикла вызвано два деструктора, но мне кажется, что должно быть три
											// Все же два, но почему? Потому, что static...
											//2)-//- 3)-//-
		}									//Три деструктора
		delete pR;							//деструктор 
		stop								//деструктор
	}


	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		std::cout << "\n\n===========================================================\nЗадание 6.\n";
		MyString str("It's my string!");
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str
		//Замечание: подумайте, как следует корректно реализовать метод GetString().
		
		std::cout << str.GetString() << std::endl;
		
		//*(str.GetString()) = 'W'; //нельзя, т.к. константный метод
		//...

		stop
	}

	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
		{
			std::cout << "\n\n===========================================================\nЗадание 6.A.\n";
			MyString str1("The first string!");
			MyString str2 = str1;
		}
		stop

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую
	std::cout << "\n\n===========================================================\nЗадание 6.Б.\n";
		MyString str1("The first string!");
		str1.SetNewString("NewString");
		stop

	//6г. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров
	std::cout << "\n\n===========================================================\nЗадание 6.Г.\n";
		
		MyString test = Skleyka("aaaa", "bbbb", "cccc", "dddd", 0);
		std::cout << test.GetString() << std::endl;
		stop

	//Задание 7.Массив объектов класса.
	{
	std::cout << "\n\n===========================================================\nЗадание 7.\n";
	//Объявите и проинициализируйте массив ar из объектов
	// типа MyString. Например:
	//Как задать размерность? N=3
		MyString ms_ar[3]; //массив из трех элементов инициализированный по-умолчанию значениями "empty"
		const int N1 = 3;
		MyString arstr1[N1] = { MyString("asdf"), MyString("wasd"), MyString("zxcv") };
	  
	//Проверка - печать строк-членов класса
		for (int i = 0; i < N1; i++)
		{
			std::cout << i+1 << "-й элемент массива: ";
			arstr1[i].Print_MyString();
		}

	//Увеличьте размер массива, не изменяя список инициализаторов:
	//N=5???
		const int N2 = 5;
		MyString arstr2[N2] = { MyString("asdf"), MyString("wasd"), MyString("zxcv") };

		//Проверка - печать строк-членов класса
		for (int i = 0; i < N2; i++)
		{
			std::cout << i + 1 << "-й элемент массива: ";
			arstr2[i].Print_MyString();
		}

	//Объявите и проинициализируйте массив объектов	типа Rect.
		Rect arrect1[N2] = { Rect(10,20,10,20), Rect(25,15,25,15), Rect(1,2,3,4), Rect(4,3,2,1) };
		for (int i = 0; i < N2; i++)
		{
			std::cout << i + 1 << "-й элемент массива: ";
			arrect1[i].Print_Rect();
		}

	}
	stop


	//Задание 8.Массив указателей на объекты класса.
	{
	std::cout << "\n\n===========================================================\nЗадание 8.\n";
	//Объявите и проинициализируйте массив arPtr из трех 
	//указателей на объекты типа MyString.
	const int N1 = 3;
	MyString * arstr3[N1] = {new MyString("asdf"), new MyString("wasd"), new MyString("zxcv") };

	//Печать строк-членов класса
	std::cout << "\n";
	for (int i = 0; i < N1; i++)
	{
		std::cout << i + 1 << "-й элемент массива: " << arstr3[i]->GetString() << std::endl;
	}
	for (int i = 0; i < N1; i++)
	{
		delete arstr3[i];
	}
	}
	stop

	//Задание 9.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.
	std::cout << "\n\n===========================================================\nЗадание 9.\n";
	Bochka spirt(100.0, 0.96);
	Bochka water(100.0, 0.0);
	int count = 0;
	//while(концентрация спирта в бочке spirt > 50%)
	while (spirt.GetConcentration() > 0.5)
	{
		water.Pereliv(spirt); // аналогично
		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
		
		//Bochka::Pereliv(spirt, water);
		count++;
	}
	std::cout << "На "<< count << " итерации концентрация спирта в первой бочке стала меньше 50%.";
	stop
}//end_main

