#include <iostream>
#include <fstream>
#include "Point.h"
#include "Circle.h" 
#include "Node.h"
#include "List.h"

#define stop __asm nop

void main()
{
	using namespace std;
	setlocale(LC_ALL, "Russian");

	/*
	Внедренные объекты.
	Объектно-ориентированный однородный двухсвязный список.
	Цель - с помощью классов реализовать список объектов типа Circle (круг).
	Последовательность действий:
	1.	Создайте класс Point
	Подумайте: какие методы и переменные должны быть определены в этом классе.

	2.	Создайте класс Circle
	Этот класс должен содержать:
	внедренный объект типа Point – центр круга
	радиус
	При конструировании объектов класса Circle предусмотрите эффективную инициализацию внедренных объектов.

	3.	Разработаем двухсвязный список, элементы которого будут являться копиями наших объектов
	Замечание: так как в списке будут фигурировать копии объектов – нам все равно, каким образом были созданы
	объекты-оригиналы (глобальные, локальные, динамические, автоматические неименованные) => манипулируя списком,
	мы несем ответственность только за уничтожение копий, а оригиналы создаются и уничтожаются независимо.

	Список реализуется двумя классами:
	3.1.	Вспомогательный класс для хранения данных и связей между объектами.
	Замечание: вспомогательный класс можно объявить независимо или «встроить» прямо в объявлении класса, реализующего список.
	Независимо от реализации удобно, чтобы все понятия вспомогательного класса были доступны методам класса List =>
	подумайте как можно это обеспечить. Альтернатива – реализация public методов для доступа к защищенным данным.

	Подсказка:
	class Node
	{
	//Данные:
	Node* pPrev;		//указатель на предыдущий элемент
	Node* pNext;		//указатель на следующий элемент
	Circle m_Data;

	//Методы:
	Node();//скорее всего понадобится для создания вспомогательных оберток – «стражей» (Head, Tail)
	Node(… ,const Circle *);	//конструктор, посредством которого создаваемый Node «подключается» в список.
	~Node();//деструктор должен «исключать» уничтожаемый Node из списка
	};

	//Реализация методов:
	//Конструктор
	Node::Node(…, const Circle * pc)…//передать параметр pc конструктору встроенного объекта m_Data
	{
	…
	}
	//Деструктор
	Node::~Node()
	{
	//Изъяли текущий элемент из списка
	…
	}

	*/


	/*
	3.2.	Основной класс, реализующий список
	Теперь вспомогательный класс Node можно использовать при создании связного списка из объектов
	типа Circle - создадим еще один класс для реализации списка – List.

	Подсказка:
	class List
	{
	//встроенное объявление класса Node

	//данные
	Node Head;	// фиктивный элемент, который является признаком начала списка
	Node Tail;	// фиктивный элемент, который является признаком конца списка
	unsigned int m_size;	//количество элементов
	public:
	List() { //сформировать Head, Tail и m_size }
	…
	};
	*/

	/*
	4.	Реализация методов
	Реализуйте самостоятельно методы класса List:
	1)	метод, который добавляет элемент в начало списка
	2)	метод, который добавляет элемент в конец списка
	3)	удаление из списка первого элемента, данное которого совпадает со значением параметра.
	Если элемент найден и удален, метод возвращает true, если элемента с таким значением в списке не было – false
	4)	удаление из списка всех элементов, данное которых совпадает со значением параметра.
	Метод возвращает количество удаленных элементов.
	5)	Сделать список пустым
	6)	добавьте в класс List остальные, необходимые на Ваш взгляд методы.
	7)
	*/


	/*
	5.	Сортировка для созданного списка и вывод результатов в файл

	Напишите для класса List
	1.	сортировку по возрастанию площади объекта.
	2.	Вывод текущего состояния списка на консоль
	cout<<l;

	3.	Вывод текущего состояния списка в файл (в форматированном виде)
	#include <fstream>
	ofstream fout(ar);
	fout<<l;
	fout.close();

	4.	Чтение из файла

	Подсказка:
	Для файловых операций воспользуйтесь объектами файлового ввода/вывода (классы ifstream и ofstream).
	Пример вывода в файл:

	{
	cout<<"Enter Output File Name  - " ;
	char ar[80];
	cin>>ar;
	ofstream fout(ar);
	fout<<100<<endl;
	fout.close();
	}
	*/





	Circle c1(0, 0, 1);
	Circle c2(0, 0, 2);
	Circle c3(0, 0, 3);
	Circle c4(0, 0, 4);
	Circle c5(0, 0, 5);

	List min;
	min.AddToTail(&c1);
	List big;
	big.AddToTail(&c2);
	big.AddToTail(&c3);
	big.AddToTail(&c4);
	big.AddToTail(&c5);
	
	List minCopy = min;
	List bigCopy = List(big);


	std::cout << "Min copy\n" << minCopy << std::endl;
	std::cout << "Big copy\n" << bigCopy << std::endl;

	minCopy = bigCopy;
	std::cout << "minCopy = bigCopy >>> " << std::endl;
	std::cout << "Min copy\n" << minCopy << std::endl;
	std::cout << "Big copy\n" << bigCopy << std::endl;
	
	std::cout << "Min copy\n" << min << std::endl;
	std::cout << "Big copy\n" << big << std::endl;
	
	big = min;
	std::cout << "min = big >>> " << std::endl;
	std::cout << "Min copy\n" << min << std::endl;
	std::cout << "Big copy\n" << big << std::endl;





	List list;
	for (int i = 0; i < 8; i++) {
		Circle c(0, 0, i);
		if (i % 2 == 0) {
			list.AddToTail(&c);
		}
		else {
			list.AddToHead(&c);
		}
	}

	std::cout << list << std::endl;
	list.SortBySquare();
	std::cout << list << std::endl;

	//save list
	{
		std::cout << "Enter Output File Name  - ";
		char ar[80] = "test.txt";
		//std::cin >> ar;
		std::cout << "Save data to - " << ar << "\n";
		std::ofstream fout(ar);
		fout << list;
		fout.close();

		//LOAD
		std::cout << "Load data from - " << ar << "\n";
		List nList;
		std::ifstream fin(ar, std::ifstream::in);
		nList << fin;
		fin.close();

		std::cout << nList;

	}


stop
}// end main